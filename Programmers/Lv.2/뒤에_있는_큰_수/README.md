## 뒤에 있는 큰 수
https://school.programmers.co.kr/learn/courses/30/lessons/154539
### 문제
정수로 이루어진 배열 numbers가 있습니다. 배열 의 각 원소들에 대해 자신보다 뒤에 있는 숫자 중에서 자신보다 크면서 가장 가까이 있는 수를 뒷 큰수라고 합니다.
정수 배열 numbers가 매개변수로 주어질 때, 모든 원소에 대한 뒷 큰수들을 차례로 담은 배열을 return 하도록 solution 함수를 완성해주세요. 단, 뒷 큰수가 존재하지 않는 원소는 -1을 담습니다.


<br />

### 입력
1) [2, 3, 3, 5]
2) [9, 1, 5, 3, 6, 2]

<br />

### 출력
1) [3, 5, 5, -1]
2) [-1, 5, 6, 6, -1, -1]

<br />

### 입출력 예 설명
입출력 예 #1
2의 뒷 큰수는 3입니다. 첫 번째 3의 뒷 큰수는 5입니다. 두 번째 3 또한 마찬가지입니다. 5는 뒷 큰수가 없으므로 -1입니다. 위 수들을 차례대로 배열에 담으면 [3, 5, 5, -1]이 됩니다.

입출력 예 #2
9는 뒷 큰수가 없으므로 -1입니다. 1의 뒷 큰수는 5이며, 5와 3의 뒷 큰수는 6입니다. 6과 2는 뒷 큰수가 없으므로 -1입니다. 위 수들을 차례대로 배열에 담으면 [-1, 5, 6, 6, -1, -1]이 됩니다.

<br />

### 제한 사항
- 4 ≤ numbers의 길이 ≤ 1,000,000
- 1 ≤ numbers[i] ≤ 1,000,000

<br />

## 풀이
- 그냥 배열을 돌면 배열이 커질 경우 시간 초과 발생
    - 자료구조 중 스택(stack)을 사용

- numbers의 길이만큼 -1로 초기화한 answer 배열 생성
    - 큰 수를 찾은 경우에만 값을 변경
- 뒤에서 큰 수를 찾지 못한 수의 인덱스를 담을 스택 생성
- numbers 순회를 돌면서 numbers[i]와 현재 stack[-1] 인덱스에 해당하는 숫자를 비교
    - numbers[i]: 현재 인덱스에 해당하는 숫자
    - stack[-1]: 스택에 있는 마지막 인덱스
        - numbers[stack[-1]]= 가장 가깝고 뒤의 큰 수를 찾지 못한 앞의 숫자
- 숫자를 비교한 결과 현재 숫자(numbers[i])가 더 크면 현재 숫자를 answer[stack.pop()]에 저장
    - 뒤에 있는 큰 수를 찾은 경우 스택에서 인덱스를 빼내야 하므로 pop()을 사용
    - 스택에 있는 모든 인덱스의 수를 비교 -> while

<br />

## 공부한 개념
- 스택(Stack)
    - 후입선출(Last In First Out, LIFO)
    - push(x): 자료 x를 넣는 작업 (== appendleft)
    - pop(): 자료를 꺼내는 작업 (== popleft)
    - peek(): 마지막에 넣은 자료를 확인하는 작업(값을 제거하지 않음)
    - is_empty(): 빈 스택인지 확인하는 작업

    - 파이썬으로 구현
        - https://wikidocs.net/192069
        - 

